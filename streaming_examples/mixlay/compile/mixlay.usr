!Case Parameters
#define MIXHEIGHT 14.


c-----------------------------------------------------------------------
c USER-DEFINED FUNCTIONS 
c    Mixing layer: two-species with variable properties
c-----------------------------------------------------------------------
      subroutine uservp (ix,iy,iz,ieg)

      !! SR: Variable properties 
      !! SR: I think we can use tabulated data of the species and then 
      !!     construct transport an ddiffusion properties here, given the 
      !!     temperature and scalar fields at each GLL point.
      !! SR wrote the whole routine, double check may be needed!

      integer ix,iy,iz,ieg,e
      real scalars_(3)   !size=temperature+scalars

      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      !! solution vars
      e = gllel(ieg)
      !ux = vx(ix,iy,iz,e)
      !uy = vy(ix,iy,iz,e)
      !uz = vz(ix,iy,iz,e)
      do i=1,ldimt
          scalars_(i)=t(ix,iy,iz,e,i)   
          !i==1: temperature
          !i==2: scalar01, ....
      enddo

      !!SR: Transport properties (species and mixture)
      if (ifield.eq.1) then      !VELOCITY+PRESS
!         utrans  = param(1)      !density
         utrans = 1*scalars_(2)+4*scalars_(3)   !TEST: update based on scalars -> WORKS! =) 
         udiff   = param(2)      !viscosity

      else if (ifield.eq.2) then   !TEMPERATURE
         utrans  = param(7)        !rho*Cp
         udiff   = param(8)        !conductivity

      else if (ifield.ge.3) then   !SCALAR01    #SHOULD CHANGE
         utrans  = cpfld(ifield,2)        !rho
         udiff   = cpfld(ifield,1)        !diffusivity

      endif

      return
      end

C-----------------------------------------------------------------------
      subroutine userf  (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      ffx = 0.0
      ffy = 0.0
      ffz = 0.0   ! you can fix the flow rate through param(54), param(55)

      return
      end

      subroutine userq  (ix,iy,iz,ieg)
      return
      end
!--------------------------------------------------
      subroutine userchk
      !implicit none   commented by saleh

      include 'SIZE'
      include 'GEOM'                    ! xm1, ym1, zm1
      include 'SOLN'                    ! T
      include 'MASS'                    !BM1 for lambda2
      include 'TSTEP'                   ! ISTEP
      include 'INPUT'           ! PARAM(12) (DT)
      include 'CHKPOINT'
!srr!      include 'USERPAR'

      !include 'TOTAL'
      real ffx_new,ffy_new,ffz_new  !saleh
      common /cforce/ ffx_new,ffy_new,ffz_new
c   for torque calculations
      real x0(3)
      save x0

      real e2
      integer n
      real ubar

!     start framework
      if (ISTEP.eq.0) call frame_start

!     monitor simulation
      call frame_monitor

!     save/load files for full-restart
      call chkpt_main

!     for tripping
      !call stat_avg

      call stream_main()

!     finalise framework
      if (ISTEP.eq.NSTEPS.or.LASTEP.eq.1) then
         call frame_end      
      endif

      return
      end

!--------------------------------------------------
      subroutine userbc (ix,iy,iz,iside,ieg)

      !implicit none
      integer ix,iy,iz,iside,eg,e
      !real y_
      include 'SIZE' 
      include 'PARALLEL'  ! GLLEL
      include 'NEKUSE'
      include 'GEOM'
      include 'TSTEP'  !SR: for ifield

      e = gllel(ieg)
      pa = 0.0

      if (cbu.eq.'o  ') then       !Dong outflow BC
         if (y.lt.(MIXHEIGHT/2)) then
            U0 = 0.5*1.1                  ! characteristic velocity
         else
            U0= 0.5*1.1
         end if
         delta = 0.1               ! small positive constant
         pa = dongOutflow(ix,iy,iz,e,iside,U0,delta)         

      elseif (cbu.eq.'v  ') then   !'v  '

         !!inlet profile for mixing layer
         if (y.lt.(MIXHEIGHT/2)) then
            ux= 0.1
            if (ifield.gt.1) then  
               if (ifield.eq.2) temp=0.5    !temperature
               if (ifield.eq.3) temp=0.25   !scalar01
               if (ifield.eq.4) temp=0.2    !scalar02
            endif
         else 
            ux= 1.0
            if (ifield.gt.1) then  
               if (ifield.eq.2) temp=1      !temperature
               if (ifield.eq.3) temp=0.5    !scalar01
               if (ifield.eq.4) temp=0.1    !scalar02
            endif
         endif  !y

         uy= 0.0 
         uz= 0.0 

      endif  !cbu

      return
      end
      
!--------------------------------------------------
      subroutine useric (ix,iy,iz,ieg)

      implicit none

      integer ix,iy,iz,ieg !,e
      !real y_

      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      if (y.lt.(MIXHEIGHT/2)) then
         ux= 0.1
         if (ifield.gt.1) then  
            if (ifield.eq.2) temp=0.5    !temperature
            if (ifield.eq.3) temp=0.25   !scalar01
            if (ifield.eq.4) temp=0.2    !scalar02
         endif
      else 
         ux= 1.0
         if (ifield.gt.1) then  
            if (ifield.eq.2) temp=1.0    !temperature
            if (ifield.eq.3) temp=0.5    !scalar01
            if (ifield.eq.4) temp=0.1    !scalar02
         endif
      endif

      uy= 0.0 
      uz= 0.0 

      return
      end
!--------------------------------------------------
      subroutine usrdat
      return
      end
!--------------------------------------------------
      subroutine usrdat2
      !implicit none

      include 'SIZE'
      include 'TOTAL'

      !set all non-periodic BCs here. This is required due to generating mesh by gmsh and converting it by gmsh2nek
      !Here are the IDs according to ellipse.msh:
      ! 1 "inlet"
      ! 2 "outlet"
      ! 3 "wall"
      ! 4 "freestreamUp"
      ! 5 "freestreamLo"
      do iel=1,nelv
         do ifc=1,2*ndim
            id_face = bc(5,ifc,iel,1)
            if (id_face.eq.1) then        ! inlet 
               cbc(ifc,iel,1) = 'v  '
            elseif (id_face.eq.2) then    ! outlet
               cbc(ifc,iel,1) = 'o  '     ! use either 'O  ' with sponge or 'o  ' with Dong BC
            elseif (id_face.eq.3) then    ! wall
               cbc(ifc,iel,1) = 'W  '
            elseif (id_face.eq.4 .OR. id_face.eq.5) then    ! surface 4/5 for free-stream
               cbc(ifc,iel,1) = 'ON '
            endif
         enddo
      enddo
      return
      end


!--------------------------------------------------
      subroutine usrdat3
c      implicit none

      return
      end

c-----------------------------------------------------------------------
      function dongOutflow(ix,iy,iz,iel,iside,u0,delta)

      include 'SIZE'
      include 'SOLN'
      include 'GEOM'

      real sn(3)

      ux = vx(ix,iy,iz,iel)
      uy = vy(ix,iy,iz,iel)
      uz = vz(ix,iy,iz,iel)

      call getSnormal(sn,ix,iy,iz,iside,iel)
      vn = ux*sn(1) + uy*sn(2) + uz*sn(3) 
      S0 = 0.5*(1.0 - tanh(vn/u0/delta))

      dongOutflow = -0.5*(ux*ux+uy*uy+uz*uz)*S0

      return
      end
C-----------------------------------------------------------------------
!======================================================================
!> @brief Register user specified modules
      subroutine frame_usr_register
      implicit none

      include 'SIZE'
      include 'FRAMELP'
!-----------------------------------------------------------------------
!     register modules
      call io_register
      call chkpt_register
      !call stat_register
      call stream_register

      return
      end subroutine
!======================================================================
!> @brief Initialise user specified modules
      subroutine frame_usr_init
      implicit none

      include 'SIZE'
      include 'FRAMELP'
      include 'SOLN'
!-----------------------------------------------------------------------
!     initialise modules
      call chkpt_init
      !call stat_init
      call stream_init

      return
      end subroutine
!======================================================================
!> @brief Finalise user specified modules
      subroutine frame_usr_end
      implicit none

      include 'SIZE'
      include 'FRAMELP'
!-----------------------------------------------------------------------
!     finalise modules
      
      return
      end subroutine
!======================================================================
!> @brief Provide element coordinates and local numbers (user interface)
!! @param[out]  idir              mapping (uniform) direction
!! @param[out]  ctrs              2D element centres
!! @param[out]  cell              local element numberring
!! @param[in]   lctrs1,lctrs2     array sizes
!! @param[out]  nelsort           number of local 3D elements to sort
!! @param[out]  map_xm1, map_ym1  2D coordinates of mapped elements
!! @param[out]  ierr              error flag
      subroutine user_map2d_get(idir,ctrs,cell,lctrs1,lctrs2,nelsort,
     $     map_xm1,map_ym1,ierr)
      implicit none

      include 'SIZE'
      include 'INPUT'           ! [XYZ]C
      include 'GEOM'            ! [XYZ]M1

!     argument list
      integer idir
      integer lctrs1,lctrs2
      real ctrs(lctrs1,lctrs2)  ! 2D element centres  and diagonals 
      integer cell(lctrs2)      ! local element numberring
      integer nelsort           ! number of local 3D elements to sort
      real map_xm1(lx1,lz1,lelt), map_ym1(lx1,lz1,lelt)
      integer ierr              ! error flag

!     local variables
      integer ntot              ! tmp array size for copying
      integer el ,il ,jl        ! loop indexes
      integer nvert             ! vertex number
      real rnvert               ! 1/nvert
      real xmid,ymid            ! 2D element centre
      real xmin,xmax,ymin,ymax  ! to get approximate element diagonal
      integer ifc               ! face number

!     dummy arrays
      real xcoord(8,LELT), ycoord(8,LELT) ! tmp vertex coordinates

!#define DEBUG
#ifdef DEBUG
!     for testing
      character*3 str1, str2
      integer iunit, ierrl
      ! call number
      integer icalldl
      save icalldl
      data icalldl /0/
#endif

!-----------------------------------------------------------------------
!     initial error flag
      ierr = 0
!     set important parameters
!     uniform direction; should be taken as input parameter
!     x-> 1, y-> 2, z-> 3
      idir = 3
      
!     get element midpoints
!     vertex number
      nvert = 2**NDIM
      rnvert= 1.0/real(nvert)

!     eliminate uniform direction
      ntot = 8*NELV
      if (idir.EQ.1) then  ! uniform X
         call copy(xcoord,YC,ntot) ! copy y
         call copy(ycoord,ZC,ntot) ! copy z
      elseif (idir.EQ.2) then  ! uniform Y
         call copy(xcoord,XC,ntot) ! copy x
         call copy(ycoord,ZC,ntot) ! copy z
      elseif (idir.EQ.3) then  ! uniform Z
         call copy(xcoord,XC,ntot) ! copy x
         call copy(ycoord,YC,ntot) ! copy y
      endif

!     set initial number of elements to sort
      nelsort = 0
      call izero(cell,NELT)

!     for every element
      do el=1,NELV
!     element centre
         xmid = xcoord(1,el)
         ymid = ycoord(1,el)

!     element diagonal
         xmin = xmid
         xmax = xmid
         ymin = ymid
         ymax = ymid
         do il=2,nvert
            xmid=xmid+xcoord(il,el)
            ymid=ymid+ycoord(il,el)
            xmin = min(xmin,xcoord(il,el))
            xmax = max(xmax,xcoord(il,el))
            ymin = min(ymin,ycoord(il,el))
            ymax = max(ymax,ycoord(il,el))
         enddo
         xmid = xmid*rnvert
         ymid = ymid*rnvert

!     count elements to sort
            nelsort = nelsort + 1
!     2D position
!     in general this coud involve some curvilinear transform
            ctrs(1,nelsort)=xmid
            ctrs(2,nelsort)=ymid
!     reference distance
            ctrs(3,nelsort)=sqrt((xmax-xmin)**2 + (ymax-ymin)**2)
            if (ctrs(3,nelsort).eq.0.0) then
               ierr = 1
               return
            endif
!     element index
            cell(nelsort) = el
      enddo

!     provide 2D mesh
!     in general this coud involve some curvilinear transform
      if (idir.EQ.1) then  ! uniform X
         ifc = 4
         do el=1,NELV
            call ftovec(map_xm1(1,1,el),ym1,el,ifc,nx1,ny1,nz1)
            call ftovec(map_ym1(1,1,el),zm1,el,ifc,nx1,ny1,nz1)
         enddo
      elseif (idir.eq.2) then  ! uniform y
         ifc = 1
         do el=1,nelv
            call ftovec(map_xm1(1,1,el),xm1,el,ifc,nx1,ny1,nz1)
            call ftovec(map_ym1(1,1,el),zm1,el,ifc,nx1,ny1,nz1)
         enddo
      elseif (idir.eq.3) then  ! uniform z
         ifc = 5
         do el=1,nelv
            call ftovec(map_xm1(1,1,el),xm1,el,ifc,nx1,ny1,nz1)
            call ftovec(map_ym1(1,1,el),ym1,el,ifc,nx1,ny1,nz1)
         enddo
      endif

#ifdef DEBUG
!     testing
      ! to output refinement
      icalldl = icalldl+1
      call io_file_freeid(iunit, ierrl)
      write(str1,'(i3.3)') NID
      write(str2,'(i3.3)') icalldl
      open(unit=iunit,file='map2d_usr.txt'//str1//'i'//str2)
      
      write(iunit,*) idir, NELV, nelsort
      write(iunit,*) 'Centre coordinates and cells'
      do el=1,nelsort
         write(iunit,*) el, ctrs(:,el), cell(el)
      enddo
      write(iunit,*) 'GLL coordinates'
      do el=1,nelsort
         write(iunit,*) 'Element ', el
         write(iunit,*) 'XM1'
         do il=1,nz1
            write(iunit,*) (map_xm1(jl,il,el),jl=1,nx1)
         enddo
         write(iunit,*) 'YM1'
         do il=1,nz1
            write(iunit,*) (map_ym1(jl,il,el),jl=1,nx1)
         enddo
      enddo
      close(iunit)
#endif

      return
      end subroutine
!=======================================================================
!> @brief Provide velocity, deriv. and vort. in required coordinates and normalise pressure
!! @param[out]   lvel             velocity
!! @param[out]   dudx,dvdx,dwdx   velocity derivatives
!! @param[out]   vort             vorticity
!! @param[inout] pres             pressure
      subroutine user_stat_trnsv(lvel,dudx,dvdx,dwdx,vort,pres)
      implicit none

      include 'SIZE'
      include 'SOLN'
      include 'INPUT'               ! if3d
      include 'GEOM'

      ! argument list
      real lvel(LX1,LY1,LZ1,LELT,3) ! velocity array
      real dudx(LX1,LY1,LZ1,LELT,3) ! velocity derivatives; U
      real dvdx(LX1,LY1,LZ1,LELT,3) ! V
      real dwdx(LX1,LY1,LZ1,LELT,3) ! W
      real vort(LX1,LY1,LZ1,LELT,3) ! vorticity
      real pres(LX1,LY1,LZ1,LELT)   ! pressure

      ! local variables
      integer itmp              ! dummy variable
      integer il, jl            ! loop index
      integer ifll              ! field number for object definition
      real vrtmp(lx1*lz1)       ! work array for face
      real vrtmp2(2)            ! work array
      real pmeanl, obj_srfl
 
      ! functions
      real vlsum
!-----------------------------------------------------------------------
      ! Velocity transformation; simple copy
      itmp = NX1*NY1*NZ1*NELV
      call copy(lvel(1,1,1,1,1),VX,itmp)
      call copy(lvel(1,1,1,1,2),VY,itmp)
      call copy(lvel(1,1,1,1,3),VZ,itmp)

      ! Derivative transformation
      ! No transformation
      call gradm1(dudx(1,1,1,1,1),dudx(1,1,1,1,2),dudx(1,1,1,1,3),
     $      lvel(1,1,1,1,1))
      call gradm1(dvdx(1,1,1,1,1),dvdx(1,1,1,1,2),dvdx(1,1,1,1,3),
     $      lvel(1,1,1,1,2))
      call gradm1(dwdx(1,1,1,1,1),dwdx(1,1,1,1,2),dwdx(1,1,1,1,3),
     $      lvel(1,1,1,1,3))

      ! get vorticity
      if (IF3D) then
         ! curlx
         call sub3(vort(1,1,1,1,1),dwdx(1,1,1,1,2),
     $        dvdx(1,1,1,1,3),itmp)
         ! curly
         call sub3(vort(1,1,1,1,2),dudx(1,1,1,1,3),
     $        dwdx(1,1,1,1,1),itmp)
      endif
      ! curlz
      call sub3(vort(1,1,1,1,3),dvdx(1,1,1,1,1),dudx(1,1,1,1,2),itmp)

      ! normalise pressure
      ! in this example I integrate pressure over all faces marked "W"
      ifll = 1     ! I'm interested in velocity bc
      call rzero(vrtmp2,2)  ! zero work array
      obj_srfl = 0.0 ! initialise object surface
      pmeanl = 0.0  ! initialise pressure mean
      itmp = LX1*LZ1
      do il=1,nelv   ! element loop
         do jl=1,2*ldim
            if (cbc(jl,il,ifll).eq.'W  ') then
               vrtmp2(1) = vrtmp2(1) + vlsum(area(1,1,jl,il),itmp)
               call ftovec(vrtmp,pres,il,jl,lx1,ly1,lz1)
               call col2(vrtmp,area(1,1,jl,il),itmp)
               vrtmp2(2) = vrtmp2(2) + vlsum(vrtmp,itmp)
            endif
         enddo
      enddo
      ! global communication
      call gop(vrtmp2,vrtmp,'+  ',2)
      ! missing error chack vrtmp2(1) == 0
      vrtmp2(2) = -vrtmp2(2)/vrtmp2(1)
!     DEBUG
!      write(*,*)'vrtmp2(1)',vrtmp2(1)      
      ! subtract mean pressure
      itmp = NX1*NY1*NZ1*NELV
      call cadd(pres,vrtmp2(2),itmp)
      
      return
      end subroutine
!======================================================================
